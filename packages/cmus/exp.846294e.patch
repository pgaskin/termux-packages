diff --git a/Doc/cmus.txt b/Doc/cmus.txt
index 6b5d848..2736617 100644
--- a/Doc/cmus.txt
+++ b/Doc/cmus.txt
@@ -526,6 +526,10 @@ player-play [filename] (*x*)
 player-prev (*z*)
 	Skips to the previous track.
 
+player-rand (*B*)
+	Skip to a random track, or to the first track of a random album when
+	*shuffle*=*albums*.
+
 player-stop (*v*)
 	Stops playback.
 
@@ -654,8 +658,8 @@ source <filename>
 	Reads and executes commands from <filename>.
 
 toggle <option>
-	Toggles the value of a toggle-able option (all booleans and tristate
-	*aaa_mode*).
+	Toggles the value of a toggle-able option (all booleans and the tristates
+	*shuffle* and *aaa_mode*).
 
 tqueue [NUM]
 	Queues NUM (default 1) random tracks from the library. See also
@@ -1141,7 +1145,7 @@ show_playback_position (true)
 show_remaining_time (false)
 	Display remaining time instead of elapsed time.
 
-shuffle (false)
+shuffle (off) [off, tracks, albums]
 	Play in shuffled order. Shuffle works in the library views (1-2) and
 	playlist view (3).
 
diff --git a/cmus.c b/cmus.c
index ed30db0..dda0c01 100644
--- a/cmus.c
+++ b/cmus.c
@@ -29,6 +29,7 @@
 #include "utils.h"
 #include "path.h"
 #include "options.h"
+#include "command_mode.h"
 #include "xmalloc.h"
 #include "debug.h"
 #include "load_dir.h"
@@ -104,6 +105,22 @@ void cmus_prev(void)
 		player_set_file(info);
 }
 
+void cmus_rand(void)
+{
+	struct track_info *info;
+
+	view_clear(QUEUE_VIEW);
+
+	if (play_library) {
+		info = lib_goto_rand();
+	} else {
+		info = pl_goto_rand();
+	}
+
+	if (info)
+		player_set_file(info);
+}
+
 void cmus_play_file(const char *filename)
 {
 	struct track_info *ti;
diff --git a/cmus.h b/cmus.h
index ae802aa..b311334 100644
--- a/cmus.h
+++ b/cmus.h
@@ -84,6 +84,7 @@ int cmus_playlist_for_each(const char *buf, int size, int reverse,
 
 void cmus_next(void);
 void cmus_prev(void);
+void cmus_rand(void);
 
 extern int cmus_next_track_request_fd;
 struct track_info *cmus_get_next_track(void);
diff --git a/command_mode.c b/command_mode.c
index e208138..c51b222 100644
--- a/command_mode.c
+++ b/command_mode.c
@@ -1393,6 +1393,11 @@ static void cmd_p_prev(char *arg)
 	}
 }
 
+static void cmd_p_rand(char *arg)
+{
+	cmus_rand();
+}
+
 static void cmd_p_stop(char *arg)
 {
 	player_stop();
@@ -1580,23 +1585,23 @@ static void cmd_win_add_q(char *arg)
 static void cmd_win_activate(char *arg)
 {
 	struct track_info *info = NULL;
-	struct shuffle_track *previous = NULL, *next = NULL;
+	struct shuffle_info *previous = NULL, *next = NULL;
 	struct rb_root *shuffle_root = NULL;
 
 	if (cur_view == TREE_VIEW || cur_view == SORTED_VIEW) {
 		if (lib_cur_track)
-			previous = &lib_cur_track->shuffle_track;
+			previous = &lib_cur_track->simple_track.shuffle_info;
 		shuffle_root = &lib_shuffle_root;
 	}
 
 	switch (cur_view) {
 	case TREE_VIEW:
 		info = tree_activate_selected();
-		next = &lib_cur_track->shuffle_track;
+		next = &lib_cur_track->simple_track.shuffle_info;
 		break;
 	case SORTED_VIEW:
 		info = sorted_activate_selected();
-		next = &lib_cur_track->shuffle_track;
+		next = &lib_cur_track->simple_track.shuffle_info;
 		break;
 	case PLAYLIST_VIEW:
 		info = pl_play_selected_row();
@@ -2596,6 +2601,7 @@ struct command commands[] = {
 	{ "player-pause-playback", cmd_p_pause_playback, 0, 0,  NULL,                 0, 0          },
 	{ "player-play",           cmd_p_play,           0, 1,  expand_playable,      0, 0          },
 	{ "player-prev",           cmd_p_prev,           0, 0,  NULL,                 0, 0          },
+	{ "player-rand",           cmd_p_rand,           0, 0,  NULL,                 0, 0          },
 	{ "player-stop",           cmd_p_stop,           0, 0,  NULL,                 0, 0          },
 	{ "prev-view",             cmd_prev_view,        0, 0,  NULL,                 0, 0          },
 	{ "left-view",             cmd_left_view,        0, 0,  NULL,                 0, 0          },
diff --git a/data/rc b/data/rc
index 046cc59..df033ed 100644
--- a/data/rc
+++ b/data/rc
@@ -4,6 +4,7 @@ bind common b player-next
 bind common c player-pause
 bind common x player-play
 bind common z player-prev
+bind common B player-rand
 bind common v player-stop
 
 bind common ] vol +0 +1%
diff --git a/lib.c b/lib.c
index 56444b5..2bf97ca 100644
--- a/lib.c
+++ b/lib.c
@@ -39,6 +39,7 @@ enum aaa_mode aaa_mode = AAA_MODE_ALL;
 char *lib_live_filter = NULL;
 
 struct rb_root lib_shuffle_root;
+struct rb_root lib_album_shuffle_root;
 static struct expr *filter = NULL;
 static struct expr *add_filter = NULL;
 static int remove_from_hash = 1;
@@ -74,7 +75,17 @@ static void all_wins_changed(void)
 
 static void shuffle_add(struct tree_track *track)
 {
-	shuffle_list_add(&track->shuffle_track, &lib_shuffle_root);
+	shuffle_list_add(&track->simple_track.shuffle_info, &lib_shuffle_root, track->album);
+}
+
+static void album_shuffle_list_add(struct album *album)
+{
+	shuffle_list_add(&album->shuffle_info, &lib_album_shuffle_root, album);
+}
+
+static void album_shuffle_list_remove(struct album *album)
+{
+	rb_erase(&album->shuffle_info.tree_node, &lib_album_shuffle_root);
 }
 
 static void views_add_track(struct track_info *ti)
@@ -87,7 +98,7 @@ static void views_add_track(struct track_info *ti)
 	/* both the hash table and views have refs */
 	track_info_ref(ti);
 
-	tree_add_track(track);
+	tree_add_track(track, album_shuffle_list_add);
 	shuffle_add(track);
 	editable_add(&lib_editable, (struct simple_track *)track);
 }
@@ -200,10 +211,13 @@ static struct tree_track *artist_last_track(const struct artist *artist)
 	return album_last_track(to_album(rb_last(&artist->album_root)));
 }
 
-static int aaa_mode_filter(const struct simple_track *track)
+static struct tree_track *normal_get_last(void)
 {
-	const struct album *album = ((struct tree_track *)track)->album;
+	return artist_last_track(to_artist(rb_last(&lib_artist_root)));
+}
 
+static int aaa_mode_filter(const struct album *album)
+{
 	if (aaa_mode == AAA_MODE_ALBUM)
 		return CUR_ALBUM == album;
 
@@ -214,12 +228,20 @@ static int aaa_mode_filter(const struct simple_track *track)
 	return 1;
 }
 
+static int cur_album_filter(const struct album *album)
+{
+	return CUR_ALBUM == album;
+}
+
 /* set next/prev (tree) {{{ */
 
-static struct tree_track *normal_get_next(void)
+static struct tree_track *normal_get_next(enum aaa_mode aaa, bool allow_repeat)
 {
-	if (lib_cur_track == NULL)
+	if (lib_cur_track == NULL) {
+		if (!allow_repeat)
+			return NULL;
 		return normal_get_first();
+	}
 
 	/* not last track of the album? */
 	if (rb_next(&lib_cur_track->tree_node)) {
@@ -227,8 +249,8 @@ static struct tree_track *normal_get_next(void)
 		return to_tree_track(rb_next(&lib_cur_track->tree_node));
 	}
 
-	if (aaa_mode == AAA_MODE_ALBUM) {
-		if (!repeat)
+	if (aaa == AAA_MODE_ALBUM) {
+		if (!allow_repeat || !repeat)
 			return NULL;
 		/* first track of the current album */
 		return album_first_track(CUR_ALBUM);
@@ -240,8 +262,8 @@ static struct tree_track *normal_get_next(void)
 		return album_first_track(to_album(rb_next(&CUR_ALBUM->tree_node)));
 	}
 
-	if (aaa_mode == AAA_MODE_ARTIST) {
-		if (!repeat)
+	if (aaa == AAA_MODE_ARTIST) {
+		if (!allow_repeat || !repeat)
 			return NULL;
 		/* first track of the first album of the current artist */
 		return artist_first_track(CUR_ARTIST);
@@ -253,17 +275,20 @@ static struct tree_track *normal_get_next(void)
 		return artist_first_track(to_artist(rb_next(&CUR_ARTIST->tree_node)));
 	}
 
-	if (!repeat)
+	if (!allow_repeat || !repeat)
 		return NULL;
 
 	/* first track */
 	return normal_get_first();
 }
 
-static struct tree_track *normal_get_prev(void)
+static struct tree_track *normal_get_prev(enum aaa_mode aaa, bool allow_repeat)
 {
-	if (lib_cur_track == NULL)
-		return normal_get_first();
+	if (lib_cur_track == NULL) {
+		if (!allow_repeat)
+			return NULL;
+		return normal_get_last();
+	}
 
 	/* not first track of the album? */
 	if (rb_prev(&lib_cur_track->tree_node)) {
@@ -271,8 +296,8 @@ static struct tree_track *normal_get_prev(void)
 		return to_tree_track(rb_prev(&lib_cur_track->tree_node));
 	}
 
-	if (aaa_mode == AAA_MODE_ALBUM) {
-		if (!repeat)
+	if (aaa == AAA_MODE_ALBUM) {
+		if (!allow_repeat || !repeat)
 			return NULL;
 		/* last track of the album */
 		return album_last_track(CUR_ALBUM);
@@ -284,8 +309,8 @@ static struct tree_track *normal_get_prev(void)
 		return album_last_track(to_album(rb_prev(&CUR_ALBUM->tree_node)));
 	}
 
-	if (aaa_mode == AAA_MODE_ARTIST) {
-		if (!repeat)
+	if (aaa == AAA_MODE_ARTIST) {
+		if (!allow_repeat || !repeat)
 			return NULL;
 		/* last track of the last album of the artist */
 		return album_last_track(to_album(rb_last(&CUR_ARTIST->album_root)));
@@ -297,11 +322,59 @@ static struct tree_track *normal_get_prev(void)
 		return artist_last_track(to_artist(rb_prev(&CUR_ARTIST->tree_node)));
 	}
 
-	if (!repeat)
+	if (!allow_repeat || !repeat)
 		return NULL;
 
 	/* last track */
-	return artist_last_track(to_artist(rb_last(&lib_artist_root)));
+	return normal_get_last();
+}
+
+static struct tree_track *shuffle_album_get_next(void)
+{
+	struct tree_track *track = NULL, *prev = NULL;
+	struct shuffle_info *shuffle_info = NULL;
+	struct album *album;
+
+	if (lib_cur_track != NULL)
+		shuffle_info = &lib_cur_track->album->shuffle_info;
+	album = (struct album *)shuffle_list_get_next(&lib_album_shuffle_root,
+			shuffle_info, aaa_mode_filter);
+	if (album != NULL)
+		track = prev = album_first_track(album);
+
+	while (play_sorted) {
+		prev = (struct tree_track *)simple_list_get_prev(&lib_editable.head,
+			   (struct simple_track *)prev, NULL, false);
+		if (prev == NULL)
+			break;
+		if (prev->album == track->album)
+			track = prev;
+	}
+	return track;
+}
+
+static struct tree_track *shuffle_album_get_prev(void)
+{
+	struct tree_track *track = NULL, *next = NULL;
+	struct shuffle_info *shuffle_info = NULL;
+	struct album *album;
+
+	if (lib_cur_track != NULL)
+		shuffle_info = &lib_cur_track->album->shuffle_info;
+	album = (struct album *)shuffle_list_get_prev(&lib_album_shuffle_root,
+			shuffle_info, aaa_mode_filter);
+	if (album != NULL)
+		track = next = album_last_track(album);
+
+	while (play_sorted) {
+		next = (struct tree_track *)simple_list_get_next(&lib_editable.head,
+			   (struct simple_track *)next, NULL, false);
+		if (next == NULL)
+			break;
+		if (next->album == track->album)
+			track = next;
+	}
+	return track;
 }
 
 /* set next/prev (tree) }}} */
@@ -309,6 +382,11 @@ static struct tree_track *normal_get_prev(void)
 void lib_reshuffle(void)
 {
 	shuffle_list_reshuffle(&lib_shuffle_root);
+	shuffle_list_reshuffle(&lib_album_shuffle_root);
+}
+
+void lib_sort_artists(void) {
+	tree_sort_artists(album_shuffle_list_add, album_shuffle_list_remove);
 }
 
 static void free_lib_track(struct editable *e, struct list_head *item)
@@ -322,8 +400,8 @@ static void free_lib_track(struct editable *e, struct list_head *item)
 	if (remove_from_hash)
 		hash_remove(ti);
 
-	rb_erase(&track->shuffle_track.tree_node, &lib_shuffle_root);
-	tree_remove(track);
+	rb_erase(&track->simple_track.shuffle_info.tree_node, &lib_shuffle_root);
+	tree_remove(track, album_shuffle_list_remove);
 
 	track_info_unref(ti);
 	free(track);
@@ -362,14 +440,22 @@ struct track_info *lib_goto_next(void)
 		BUG_ON(lib_cur_track != NULL);
 		return NULL;
 	}
-	if (shuffle) {
+	if (shuffle == SHUFFLE_TRACKS) {
 		track = (struct tree_track *)shuffle_list_get_next(&lib_shuffle_root,
-				(struct shuffle_track *)lib_cur_track, aaa_mode_filter);
+				(struct shuffle_info *)lib_cur_track, aaa_mode_filter);
+	} else if (shuffle == SHUFFLE_ALBUMS) {
+		if (play_sorted)
+			track = (struct tree_track *)simple_list_get_next(&lib_editable.head,
+					(struct simple_track *)lib_cur_track, cur_album_filter, false);
+		else
+			track = normal_get_next(AAA_MODE_ALBUM, false);
+		if (track == NULL)
+			track = shuffle_album_get_next();
 	} else if (play_sorted) {
 		track = (struct tree_track *)simple_list_get_next(&lib_editable.head,
-				(struct simple_track *)lib_cur_track, aaa_mode_filter);
+				(struct simple_track *)lib_cur_track, aaa_mode_filter, true);
 	} else {
-		track = normal_get_next();
+		track = normal_get_next(aaa_mode, true);
 	}
 	return lib_set_track(track);
 }
@@ -382,18 +468,43 @@ struct track_info *lib_goto_prev(void)
 		BUG_ON(lib_cur_track != NULL);
 		return NULL;
 	}
-	if (shuffle) {
+	if (shuffle == SHUFFLE_TRACKS) {
 		track = (struct tree_track *)shuffle_list_get_prev(&lib_shuffle_root,
-				(struct shuffle_track *)lib_cur_track, aaa_mode_filter);
+				(struct shuffle_info *)lib_cur_track, aaa_mode_filter);
+	} else if (shuffle == SHUFFLE_ALBUMS) {
+		if (play_sorted)
+			track = (struct tree_track *)simple_list_get_prev(&lib_editable.head,
+					(struct simple_track *)lib_cur_track, cur_album_filter, false);
+		else
+			track = normal_get_prev(AAA_MODE_ALBUM, false);
+		if (track == NULL)
+			track = shuffle_album_get_prev();
 	} else if (play_sorted) {
 		track = (struct tree_track *)simple_list_get_prev(&lib_editable.head,
-				(struct simple_track *)lib_cur_track, aaa_mode_filter);
+				(struct simple_track *)lib_cur_track, aaa_mode_filter, true);
 	} else {
-		track = normal_get_prev();
+		track = normal_get_prev(aaa_mode, true);
 	}
 	return lib_set_track(track);
 }
 
+struct track_info *lib_goto_rand(void)
+{
+	struct tree_track *track;
+
+	if (rb_root_empty(&lib_artist_root)) {
+		BUG_ON(lib_cur_track != NULL);
+		return NULL;
+	}
+	if (shuffle == SHUFFLE_ALBUMS)
+		track = shuffle_album_get_next();
+	else
+		track = (struct tree_track *)shuffle_list_get_next(&lib_shuffle_root,
+				(struct shuffle_info *)lib_cur_track, aaa_mode_filter);
+
+	return lib_set_track(track);
+}
+
 static struct tree_track *sorted_get_selected(void)
 {
 	struct iter sel;
diff --git a/lib.h b/lib.h
index f7f685a..53709e4 100644
--- a/lib.h
+++ b/lib.h
@@ -26,7 +26,7 @@
 #include "rbtree.h"
 
 struct tree_track {
-	struct shuffle_track shuffle_track;
+	struct simple_track simple_track;
 
 	/* position in track search tree */
 	struct rb_node tree_node;
@@ -46,6 +46,8 @@ static inline struct tree_track *to_tree_track(const struct rb_node *node)
 
 
 struct album {
+	struct shuffle_info shuffle_info;
+
 	/* position in album search tree */
 	struct rb_node tree_node;
 
@@ -93,6 +95,7 @@ enum aaa_mode {
 extern struct editable lib_editable;
 extern struct tree_track *lib_cur_track;
 extern struct rb_root lib_shuffle_root;
+extern struct rb_root lib_album_shuffle_root;
 extern enum aaa_mode aaa_mode;
 extern unsigned int play_sorted;
 extern char *lib_live_filter;
@@ -110,6 +113,7 @@ void lib_init(void);
 void tree_init(void);
 struct track_info *lib_goto_next(void);
 struct track_info *lib_goto_prev(void);
+struct track_info *lib_goto_rand(void);
 void lib_add_track(struct track_info *track_info, void *opaque);
 void lib_set_filter(struct expr *expr);
 void lib_set_live_filter(const char *str);
@@ -117,6 +121,7 @@ void lib_set_add_filter(struct expr *expr);
 int lib_remove(struct track_info *ti);
 void lib_clear_store(void);
 void lib_reshuffle(void);
+void lib_sort_artists(void);
 void lib_set_view(int view);
 int lib_for_each(int (*cb)(void *data, struct track_info *ti), void *data,
 		void *opaque);
@@ -130,9 +135,9 @@ struct track_info *lib_get_cur_stored_track(void);
 
 struct tree_track *tree_get_selected(void);
 struct track_info *tree_activate_selected(void);
-void tree_sort_artists(void);
-void tree_add_track(struct tree_track *track);
-void tree_remove(struct tree_track *track);
+void tree_sort_artists(void (*add_album_cb)(struct album *), void (*remove_album_cb)(struct album *));
+void tree_add_track(struct tree_track *track, void (*add_album_cb)(struct album *));
+void tree_remove(struct tree_track *track, void (*remove_album_cb)(struct album *));
 void tree_remove_sel(void);
 void tree_toggle_active_window(void);
 void tree_toggle_expand_artist(void);
diff --git a/options.c b/options.c
index 93b1c35..df3407b 100644
--- a/options.c
+++ b/options.c
@@ -653,11 +653,9 @@ static void toggle_play_sorted(void *data)
 {
 	play_sorted = play_sorted ^ 1;
 
-	/* shuffle would override play_sorted... */
 	if (play_sorted) {
 		/* play_sorted makes no sense in playlist */
 		play_library = 1;
-		shuffle = 0;
 	}
 
 	update_statusline();
@@ -671,13 +669,13 @@ static void get_smart_artist_sort(void *data, char *buf, size_t size)
 static void set_smart_artist_sort(void *data, const char *buf)
 {
 	if (parse_bool(buf, &smart_artist_sort))
-		tree_sort_artists();
+		lib_sort_artists();
 }
 
 static void toggle_smart_artist_sort(void *data)
 {
 	smart_artist_sort ^= 1;
-	tree_sort_artists();
+	lib_sort_artists();
 }
 
 static void get_display_artist_sort_name(void *data, char *buf, size_t size)
@@ -1002,25 +1000,38 @@ static void toggle_set_term_title(void *data)
 	set_term_title ^= 1;
 }
 
+const char * const shuffle_names[] = {
+	"off", "tracks", "albums", NULL
+};
+
 static void get_shuffle(void *data, char *buf, size_t size)
 {
-	strscpy(buf, bool_names[shuffle], size);
+	strscpy(buf, shuffle_names[shuffle], size);
 }
 
 static void set_shuffle(void *data, const char *buf)
 {
-	int old = shuffle;
-	if (!parse_bool(buf, &shuffle))
+	int tmp;
+
+	if (!parse_enum(buf, 0, 2, shuffle_names, &tmp))
 		return;
-	if (old != shuffle)
+
+	if (tmp != shuffle)
 		mpris_shuffle_changed();
+
+	shuffle = tmp;
 	update_statusline();
 }
 
 static void toggle_shuffle(void *data)
 {
-	shuffle ^= 1;
-	mpris_shuffle_changed();
+	shuffle++;
+	shuffle %= 3;
+
+	/* album mode makes no sense in playlist */
+	if (!play_library && shuffle == SHUFFLE_ALBUMS)
+		shuffle = SHUFFLE_OFF;
+
 	update_statusline();
 }
 
diff --git a/options.h b/options.h
index 78c5f4e..a7c9751 100644
--- a/options.h
+++ b/options.h
@@ -116,6 +116,12 @@ enum {
 	NR_ATTRS
 };
 
+enum shuffle_mode {
+	SHUFFLE_OFF,
+	SHUFFLE_TRACKS,
+	SHUFFLE_ALBUMS
+};
+
 #define BRIGHT (1 << 3)
 
 extern char *cdda_device;
diff --git a/pl.c b/pl.c
index 6397224..9f447c5 100644
--- a/pl.c
+++ b/pl.c
@@ -176,13 +176,12 @@ static void pl_free_track(struct editable *e, struct list_head *item)
 {
 	struct playlist *pl = pl_from_editable(e);
 	struct simple_track *track = to_simple_track(item);
-	struct shuffle_track *shuffle_track =
-		simple_track_to_shuffle_track(track);
+	struct shuffle_info *shuffle_info = &track->shuffle_info;
 
 	if (track == pl->cur_track)
 		pl->cur_track = NULL;
 
-	rb_erase(&shuffle_track->tree_node, &pl->shuffle_root);
+	rb_erase(&shuffle_info->tree_node, &pl->shuffle_root);
 	track_info_unref(track->info);
 	free(track);
 }
@@ -204,12 +203,12 @@ static void pl_free(struct playlist *pl)
 
 static void pl_add_track(struct playlist *pl, struct track_info *ti)
 {
-	struct shuffle_track *track = xnew(struct shuffle_track, 1);
+	struct simple_track *track = xnew(struct simple_track, 1);
 
 	track_info_ref(ti);
-	simple_track_init(&track->simple_track, ti);
-	shuffle_list_add(track, &pl->shuffle_root);
-	editable_add(&pl->editable, &track->simple_track);
+	simple_track_init(track, ti);
+	shuffle_list_add(&track->shuffle_info, &pl->shuffle_root, NULL);
+	editable_add(&pl->editable, track);
 }
 
 static void pl_add_cb(struct track_info *ti, void *opaque)
@@ -292,11 +291,6 @@ static void pl_list_sel_changed(void)
 	editable_take_ownership(&pl_visible->editable);
 }
 
-static int pl_dummy_filter(const struct simple_track *track)
-{
-	return 1;
-}
-
 static int pl_empty(struct playlist *pl)
 {
 	return editable_empty(&pl->editable);
@@ -315,14 +309,14 @@ static struct simple_track *pl_get_first_track(struct playlist *pl)
 	/* pl is not empty */
 
 	if (shuffle) {
-		struct shuffle_track *st = shuffle_list_get_next(&pl->shuffle_root, NULL, pl_dummy_filter);
-		return &st->simple_track;
+		struct shuffle_info *si = shuffle_list_get_next(&pl->shuffle_root, NULL, NULL);
+		return shuffle_info_to_simple_track(si);
 	} else {
 		return to_simple_track(pl->editable.head.next);
 	}
 }
 
-static struct track_info *pl_play_track(struct playlist *pl, struct simple_track *t)
+static struct track_info *pl_play_track(struct playlist *pl, struct simple_track *t, bool force_follow)
 {
 	/* t is a track in pl */
 
@@ -333,7 +327,7 @@ static struct track_info *pl_play_track(struct playlist *pl, struct simple_track
 	pl_playing = pl;
 	pl_editable_shared.win->changed = 1;
 
-	if (follow)
+	if (force_follow || follow)
 		pl_select_playing_track();
 
 	/* reference owned by the caller */
@@ -347,7 +341,7 @@ static struct track_info *pl_play_selected_track(void)
 	if (pl_empty(pl_visible))
 		return NULL;
 
-	return pl_play_track(pl_visible, pl_get_selected_track());
+	return pl_play_track(pl_visible, pl_get_selected_track(), false);
 }
 
 static struct track_info *pl_play_first_in_pl_playing(void)
@@ -360,34 +354,48 @@ static struct track_info *pl_play_first_in_pl_playing(void)
 		return NULL;
 	}
 
-	return pl_play_track(pl_playing, pl_get_first_track(pl_playing));
+	return pl_play_track(pl_playing, pl_get_first_track(pl_playing), false);
+}
+
+static struct track_info *pl_play_rand_in_pl_playing(void)
+{
+	if (!pl_playing)
+		pl_playing = pl_visible;
+
+	if (pl_empty(pl_playing)) {
+		pl_playing = NULL;
+		return NULL;
+	}
+
+	struct shuffle_info *si = shuffle_list_get_next(&pl_playing->shuffle_root, NULL, NULL);
+	return pl_play_track(pl_playing, shuffle_info_to_simple_track(si), false);
 }
 
 static struct simple_track *pl_get_next(struct playlist *pl, struct simple_track *cur)
 {
-	return simple_list_get_next(&pl->editable.head, cur, pl_dummy_filter);
+	return simple_list_get_next(&pl->editable.head, cur, NULL, true);
 }
 
 static struct simple_track *pl_get_next_shuffled(struct playlist *pl,
 		struct simple_track *cur)
 {
-	struct shuffle_track *st = simple_track_to_shuffle_track(cur);
-	st = shuffle_list_get_next(&pl->shuffle_root, st, pl_dummy_filter);
-	return &st->simple_track;
+	struct shuffle_info *si = &cur->shuffle_info;
+	si = shuffle_list_get_next(&pl->shuffle_root, si, NULL);
+	return shuffle_info_to_simple_track(si);
 }
 
 static struct simple_track *pl_get_prev(struct playlist *pl,
 		struct simple_track *cur)
 {
-	return simple_list_get_prev(&pl->editable.head, cur, pl_dummy_filter);
+	return simple_list_get_prev(&pl->editable.head, cur, NULL, true);
 }
 
 static struct simple_track *pl_get_prev_shuffled(struct playlist *pl,
 		struct simple_track *cur)
 {
-	struct shuffle_track *st = simple_track_to_shuffle_track(cur);
-	st = shuffle_list_get_prev(&pl->shuffle_root, st, pl_dummy_filter);
-	return &st->simple_track;
+	struct shuffle_info *si = &cur->shuffle_info;
+	si = shuffle_list_get_prev(&pl->shuffle_root, si, NULL);
+	return shuffle_info_to_simple_track(si);
 }
 
 static int pl_match_add_job(uint32_t type, void *job_data, void *opaque)
@@ -490,7 +498,7 @@ static struct track_info *pl_goto_generic(pl_shuffled_move shuffled,
 		track = normal(pl_playing, pl_playing_track);
 
 	if (track)
-		return pl_play_track(pl_playing, track);
+		return pl_play_track(pl_playing, track, false);
 	return NULL;
 }
 
@@ -638,6 +646,20 @@ struct track_info *pl_goto_prev(void)
 	return pl_goto_generic(pl_get_prev_shuffled, pl_get_prev);
 }
 
+struct track_info *pl_goto_rand(void)
+{
+	struct simple_track *track;
+
+	if (!pl_playing_track)
+		return pl_play_rand_in_pl_playing();
+
+	track = pl_get_next_shuffled(pl_playing, pl_playing_track);
+
+	if (!track)
+		return NULL;
+	return pl_play_track(pl_playing, track, false);
+}
+
 struct track_info *pl_play_selected_row(void)
 {
 	/* a bit tricky because we want to insert the selected track at the
@@ -647,28 +669,26 @@ struct track_info *pl_play_selected_row(void)
 
 	int was_in_track_window = pl_cursor_in_track_window;
 
+	struct playlist *prev_pl = pl_playing;
+	struct simple_track *prev_track = pl_playing_track;
+
 	struct track_info *rv = NULL;
 
 	if (!pl_cursor_in_track_window) {
 		if (shuffle && !pl_empty(pl_visible)) {
-			struct shuffle_track *st = shuffle_list_get_next(&pl_visible->shuffle_root, NULL, pl_dummy_filter);
-			struct simple_track *track = &st->simple_track;
-			rv = pl_play_track(pl_visible, track);
+			struct shuffle_info *si = shuffle_list_get_next(&pl_visible->shuffle_root, NULL, NULL);
+			struct simple_track *track = shuffle_info_to_simple_track(si);
+			rv = pl_play_track(pl_visible, track, true);
 		}
 	}
-	pl_select_playing_track();
 
 	if (!rv)
 		rv = pl_play_selected_track();
 
-	struct playlist *prev_pl = pl_playing;
-	struct simple_track *prev_track = pl_playing_track;
-
 	if (shuffle && rv && (pl_playing == prev_pl) && prev_track) {
-		struct shuffle_track *prev_st = simple_track_to_shuffle_track(prev_track);
-		struct shuffle_track *cur_st =
-			simple_track_to_shuffle_track(pl_playing_track);
-		shuffle_insert(&pl_playing->shuffle_root, prev_st, cur_st);
+		struct shuffle_info *prev_si = &prev_track->shuffle_info;
+		struct shuffle_info *cur_si = &pl_playing_track->shuffle_info;
+		shuffle_insert(&pl_playing->shuffle_root, prev_si, cur_si);
 	}
 
 	pl_cursor_in_track_window = was_in_track_window;
diff --git a/pl.h b/pl.h
index b2e93ec..77b054b 100644
--- a/pl.h
+++ b/pl.h
@@ -50,6 +50,7 @@ void pl_set_sort_str(const char *buf);
 void pl_clear(void);
 struct track_info *pl_goto_next(void);
 struct track_info *pl_goto_prev(void);
+struct track_info *pl_goto_rand(void);
 struct track_info *pl_play_selected_row(void);
 void pl_select_playing_track(void);
 void pl_reshuffle(void);
diff --git a/track.c b/track.c
index fc911ea..15d61d3 100644
--- a/track.c
+++ b/track.c
@@ -17,6 +17,7 @@
  */
 
 #include "track.h"
+#include "lib.h"
 #include "iter.h"
 #include "search_mode.h"
 #include "window.h"
@@ -71,7 +72,7 @@ int simple_track_search_matches(void *data, struct iter *iter, const char *text)
 	return rc;
 }
 
-void shuffle_insert(struct rb_root *root, struct shuffle_track *previous, struct shuffle_track *next)
+void shuffle_insert(struct rb_root *root, struct shuffle_info *previous, struct shuffle_info *next)
 {
 	BUG_ON(root == NULL);
 	BUG_ON(next == NULL);
@@ -91,20 +92,23 @@ void shuffle_insert(struct rb_root *root, struct shuffle_track *previous, struct
 	rb_insert_color(&next->tree_node, root);
 }
 
-struct shuffle_track *shuffle_list_get_next(struct rb_root *root, struct shuffle_track *cur,
-		int (*filter_callback)(const struct simple_track *))
+struct shuffle_info *shuffle_list_get_next(struct rb_root *root, struct shuffle_info *cur,
+		int (*filter_callback)(const struct album *))
 {
 	struct rb_node *node;
 
-	if (!cur)
-		return tree_node_to_shuffle_track(rb_first(root));
+	if (!cur) {
+		if (auto_reshuffle)
+			shuffle_list_reshuffle(root);
+		return tree_node_to_shuffle_info(rb_first(root));
+	}
 
 	node = rb_next(&cur->tree_node);
 again:
 	while (node) {
-		struct shuffle_track *track = tree_node_to_shuffle_track(node);
+		struct shuffle_info *track = tree_node_to_shuffle_info(node);
 
-		if (filter_callback((struct simple_track *)track))
+		if (filter_callback == NULL || filter_callback(track->album))
 			return track;
 		node = rb_next(node);
 	}
@@ -117,20 +121,23 @@ again:
 	return NULL;
 }
 
-struct shuffle_track *shuffle_list_get_prev(struct rb_root *root, struct shuffle_track *cur,
-		int (*filter_callback)(const struct simple_track *))
+struct shuffle_info *shuffle_list_get_prev(struct rb_root *root, struct shuffle_info *cur,
+		int (*filter_callback)(const struct album *))
 {
 	struct rb_node *node;
 
-	if (!cur)
-		return tree_node_to_shuffle_track(rb_last(root));
+	if (!cur) {
+		if (auto_reshuffle)
+			shuffle_list_reshuffle(root);
+		return tree_node_to_shuffle_info(rb_last(root));
+	}
 
 	node = rb_prev(&cur->tree_node);
 again:
 	while (node) {
-		struct shuffle_track *track = tree_node_to_shuffle_track(node);
+		struct shuffle_info *track = tree_node_to_shuffle_info(node);
 
-		if (filter_callback((struct simple_track *)track))
+		if (filter_callback == NULL || filter_callback(track->album))
 			return track;
 		node = rb_prev(node);
 	}
@@ -144,47 +151,53 @@ again:
 }
 
 struct simple_track *simple_list_get_next(struct list_head *head, struct simple_track *cur,
-		int (*filter_callback)(const struct simple_track *))
+		int (*filter_callback)(const struct album *), bool allow_repeat)
 {
 	struct list_head *item;
 
-	if (cur == NULL)
+	if (cur == NULL) {
+		if (!allow_repeat)
+			return NULL;
 		return to_simple_track(head->next);
+	}
 
 	item = cur->node.next;
 again:
 	while (item != head) {
 		struct simple_track *track = to_simple_track(item);
 
-		if (filter_callback(track))
+		if (filter_callback == NULL || filter_callback(((struct tree_track *)track)->album))
 			return track;
 		item = item->next;
 	}
 	item = head->next;
-	if (repeat)
+	if (allow_repeat && repeat)
 		goto again;
 	return NULL;
 }
 
 struct simple_track *simple_list_get_prev(struct list_head *head, struct simple_track *cur,
-		int (*filter_callback)(const struct simple_track *))
+		int (*filter_callback)(const struct album *), bool allow_repeat)
 {
 	struct list_head *item;
 
-	if (cur == NULL)
-		return to_simple_track(head->next);
+	if (cur == NULL) {
+		if (!allow_repeat)
+			return NULL;
+		return to_simple_track(head->prev);
+	}
 
 	item = cur->node.prev;
 again:
 	while (item != head) {
 		struct simple_track *track = to_simple_track(item);
 
-		if (filter_callback(track))
+		if (filter_callback == NULL || filter_callback(((struct tree_track *)track)->album))
 			return track;
 		item = item->prev;
 	}
 	item = head->prev;
-	if (repeat)
+	if (allow_repeat && repeat)
 		goto again;
 	return NULL;
 }
@@ -303,8 +316,8 @@ void sorted_list_rebuild(struct list_head *head, struct rb_root *tree_root, cons
 
 static int compare_rand(const struct rb_node *a, const struct rb_node *b)
 {
-	struct shuffle_track *tr_a = tree_node_to_shuffle_track(a);
-	struct shuffle_track *tr_b = tree_node_to_shuffle_track(b);
+	struct shuffle_info *tr_a = tree_node_to_shuffle_info(a);
+	struct shuffle_info *tr_b = tree_node_to_shuffle_info(b);
 
 	if (tr_a->rand < tr_b->rand)
 		return -1;
@@ -314,16 +327,17 @@ static int compare_rand(const struct rb_node *a, const struct rb_node *b)
 	return 0;
 }
 
-static void shuffle_track_init(struct shuffle_track *track)
+static void shuffle_info_init(struct shuffle_info *info, struct album *album)
 {
-	track->rand = rand() / ((double) RAND_MAX + 1);
+	info->rand = rand() / ((double) RAND_MAX + 1);
+	info->album = album;
 }
 
-void shuffle_list_add(struct shuffle_track *track, struct rb_root *tree_root)
+void shuffle_list_add(struct shuffle_info *track, struct rb_root *tree_root, struct album *album)
 {
 	struct rb_node **new = &(tree_root->rb_node), *parent = NULL;
 
-	shuffle_track_init(track);
+	shuffle_info_init(track, album);
 
 	/* try to locate track in tree */
 	while (*new) {
@@ -336,7 +350,7 @@ void shuffle_list_add(struct shuffle_track *track, struct rb_root *tree_root)
 			new = &((*new)->rb_right);
 		else {
 			/* very unlikely, try again! */
-			shuffle_list_add(track, tree_root);
+			shuffle_list_add(track, tree_root, album);
 			return;
 		}
 	}
@@ -351,9 +365,10 @@ void shuffle_list_reshuffle(struct rb_root *tree_root)
 	struct rb_root tmptree = RB_ROOT;
 
 	rb_for_each_safe(node, tmp, tree_root) {
-		struct shuffle_track *track = tree_node_to_shuffle_track(node);
+		struct shuffle_info *track = tree_node_to_shuffle_info(node);
+		struct album *album = track->album;
 		rb_erase(node, tree_root);
-		shuffle_list_add(track, &tmptree);
+		shuffle_list_add(track, &tmptree, album);
 	}
 
 	tree_root->rb_node = tmptree.rb_node;
diff --git a/track.h b/track.h
index aa84ef9..76f92cf 100644
--- a/track.h
+++ b/track.h
@@ -25,26 +25,27 @@
 #include "track_info.h"
 #include "cmus.h"
 
+struct shuffle_info {
+	struct rb_node tree_node;
+	struct album *album;
+	double rand;
+};
+
 struct simple_track {
+	struct shuffle_info shuffle_info;
 	struct list_head node;
 	struct rb_node tree_node;
 	struct track_info *info;
 	unsigned int marked : 1;
 };
 
-struct shuffle_track {
-	struct simple_track simple_track;
-	struct rb_node tree_node;
-	double rand;
-};
-
-static inline struct shuffle_track *
-simple_track_to_shuffle_track(struct simple_track *track)
+static inline struct simple_track *
+shuffle_info_to_simple_track(struct shuffle_info *track)
 {
-	return container_of(track, struct shuffle_track, simple_track);
+	return container_of(track, struct simple_track, shuffle_info);
 }
 
-static inline struct track_info *shuffle_track_info(const struct shuffle_track *track)
+static inline struct track_info *shuffle_info_info(const struct shuffle_info *track)
 {
 	return ((struct simple_track *)track)->info;
 }
@@ -64,9 +65,9 @@ static inline struct simple_track *tree_node_to_simple_track(const struct rb_nod
 	return container_of(node, struct simple_track, tree_node);
 }
 
-static inline struct shuffle_track *tree_node_to_shuffle_track(const struct rb_node *node)
+static inline struct shuffle_info *tree_node_to_shuffle_info(const struct rb_node *node)
 {
-	return container_of(node, struct shuffle_track, tree_node);
+	return container_of(node, struct shuffle_info, tree_node);
 }
 
 /* NOTE: does not ref ti */
@@ -83,17 +84,17 @@ int simple_track_search_get_current(void *data, struct iter *iter);
 int simple_track_search_matches(void *data, struct iter *iter, const char *text);
 int _simple_track_search_matches(struct iter *iter, const char *text);
 
-struct shuffle_track *shuffle_list_get_next(struct rb_root *root, struct shuffle_track *cur,
-		int (*filter)(const struct simple_track *));
+struct shuffle_info *shuffle_list_get_next(struct rb_root *root, struct shuffle_info *cur,
+		int (*filter)(const struct album *));
 
-struct shuffle_track *shuffle_list_get_prev(struct rb_root *root, struct shuffle_track *cur,
-		int (*filter)(const struct simple_track *));
+struct shuffle_info *shuffle_list_get_prev(struct rb_root *root, struct shuffle_info *cur,
+		int (*filter)(const struct album *));
 
 struct simple_track *simple_list_get_next(struct list_head *head, struct simple_track *cur,
-		int (*filter)(const struct simple_track *));
+		int (*filter)(const struct album *), bool allow_repeat);
 
 struct simple_track *simple_list_get_prev(struct list_head *head, struct simple_track *cur,
-		int (*filter)(const struct simple_track *));
+		int (*filter)(const struct album *), bool allow_repeat);
 
 void sorted_list_add_track(struct list_head *head, struct rb_root *tree_root, struct simple_track *track,
 		const sort_key_t *keys, int tiebreak);
@@ -108,8 +109,8 @@ int simple_list_for_each_marked(struct list_head *head, track_info_cb cb,
 int simple_list_for_each(struct list_head *head, track_info_cb cb,
 		void *data, int reverse);
 
-void shuffle_list_add(struct shuffle_track *track, struct rb_root *tree_root);
+void shuffle_list_add(struct shuffle_info *track, struct rb_root *tree_root, struct album *album);
 void shuffle_list_reshuffle(struct rb_root *tree_root);
-void shuffle_insert(struct rb_root *root, struct shuffle_track *previous, struct shuffle_track *new);
+void shuffle_insert(struct rb_root *root, struct shuffle_info *previous, struct shuffle_info *new);
 
 #endif
diff --git a/tree.c b/tree.c
index 105eec3..304ed10 100644
--- a/tree.c
+++ b/tree.c
@@ -914,7 +914,8 @@ static void remove_artist(struct artist *artist)
 	rb_erase(&artist->tree_node, &lib_artist_root);
 }
 
-void tree_add_track(struct tree_track *track)
+void tree_add_track(struct tree_track *track,
+		void (*add_album_cb)(struct album *))
 {
 	const struct track_info *ti = tree_track_info(track);
 	const char *album_name, *artist_name, *artistsort_name = NULL;
@@ -1005,6 +1006,7 @@ void tree_add_track(struct tree_track *track)
 
 	} else if (artist) {
 		add_album(new_album);
+		add_album_cb(new_album);
 		album_add_track(new_album, track);
 
 		if (artist->expanded)
@@ -1012,6 +1014,7 @@ void tree_add_track(struct tree_track *track)
 	} else {
 		add_artist(new_artist);
 		add_album(new_album);
+		add_album_cb(new_album);
 		album_add_track(new_album, track);
 
 		window_changed(lib_tree_win);
@@ -1179,7 +1182,8 @@ static void remove_track(struct tree_track *track)
 	rb_erase(&track->tree_node, &track->album->track_root);
 }
 
-void tree_remove(struct tree_track *track)
+void tree_remove(struct tree_track *track,
+		void (*remove_album_cb)(struct album *))
 {
 	struct album *album = track->album;
 	struct artist *sel_artist;
@@ -1203,6 +1207,7 @@ void tree_remove(struct tree_track *track)
 		}
 
 		remove_album(album);
+		remove_album_cb(album);
 		album_free(album);
 
 		if (rb_root_empty(&artist->album_root)) {
@@ -1222,7 +1227,8 @@ void tree_remove_sel(void)
 	}
 }
 
-void tree_sort_artists(void)
+void tree_sort_artists(void (*add_album_cb)(struct album *),
+		void (*remove_album_cb)(struct album *))
 {
 	struct rb_node *a_node, *a_tmp;
 
@@ -1237,8 +1243,8 @@ void tree_sort_artists(void)
 			rb_for_each_safe(t_node, t_tmp, &album->track_root) {
 				struct tree_track *track = to_tree_track(t_node);
 
-				tree_remove(track);
-				tree_add_track(track);
+				tree_remove(track, remove_album_cb);
+				tree_add_track(track, add_album_cb);
 			}
 		}
 	}
diff --git a/ui_curses.c b/ui_curses.c
index d67e0ad..37889b4 100644
--- a/ui_curses.c
+++ b/ui_curses.c
@@ -667,7 +667,7 @@ const struct format_option *get_global_fopts(void)
 	static const char *cont_strs[] = { " ", "C" };
 	static const char *follow_strs[] = { " ", "F" };
 	static const char *repeat_strs[] = { " ", "R" };
-	static const char *shuffle_strs[] = { " ", "S" };
+	static const char *shuffle_strs[] = { " ", "S", "&" };
 	int buffer_fill, vol, vol_left, vol_right;
 	int duration = -1;
 
